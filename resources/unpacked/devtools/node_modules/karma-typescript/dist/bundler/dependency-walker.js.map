{"version":3,"file":"dependency-walker.js","sourceRoot":"","sources":["../../src/bundler/dependency-walker.ts"],"names":[],"mappings":"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","sourcesContent":["import * as async from \"async\";\nimport * as diff from \"diff\";\nimport * as fs from \"fs\";\nimport * as glob from \"glob\";\nimport * as lodash from \"lodash\";\nimport * as os from \"os\";\nimport * as path from \"path\";\nimport * as ts from \"typescript\";\n\nimport { Logger } from \"log4js\";\n\nimport pad = require(\"pad\");\n\nimport { EmitOutput } from \"../compiler/emit-output\";\nimport { BundleItem } from \"./bundle-item\";\nimport { Queued } from \"./queued\";\n\nexport class DependencyWalker {\n\n    private requireRegexp = /\\brequire\\b/;\n    private walk = require(\"acorn-walk\");\n\n    constructor(private log: Logger) {}\n\n    public hasRequire(s: string): boolean {\n        return this.requireRegexp.test(s);\n    }\n\n    public collectTypescriptDependencies(queue: Queued[]): number {\n\n        let dependencyCount: number = 0;\n        const ambientModuleNames = this.collectAmbientModules(queue);\n\n        queue.forEach((queued) => {\n\n            queued.item.dependencies = this.findUnresolvedTsRequires(queued.emitOutput);\n\n            const resolvedModules = (queued.emitOutput.sourceFile as any).resolvedModules;\n\n            if (resolvedModules && !queued.emitOutput.isDeclarationFile) {\n\n                if (lodash.isMap(resolvedModules)) { // Typescript 2.2+\n                    resolvedModules.forEach((resolvedModule: any, moduleName: string) => {\n                        this.addBundleItem(queued, resolvedModule, moduleName, ambientModuleNames);\n                    });\n                }\n                else { // Typescript 1.6.2 - 2.1.6\n                    Object.keys(resolvedModules).forEach((moduleName: string) => {\n                        const resolvedModule = resolvedModules[moduleName];\n                        this.addBundleItem(queued, resolvedModule, moduleName, ambientModuleNames);\n                    });\n                }\n            }\n\n            dependencyCount += queued.item.dependencies.length;\n        });\n\n        this.validateCase(queue);\n\n        return dependencyCount;\n    }\n\n    public collectJavascriptDependencies(bundleItem: BundleItem,\n                                         onDependenciesCollected: (moduleNames: string[]) => void): void {\n\n        const moduleNames: string[] = [];\n        const expressions: any[] = [];\n\n        const isRequire = (node: any) => {\n            return node.type === \"CallExpression\" &&\n                   node.callee.type === \"Identifier\" &&\n                   node.callee.name === \"require\";\n        };\n\n        const visitNode = (node: any, state: any, c: any)  => {\n            if (!this.hasRequire(bundleItem.source.slice(node.start, node.end))) {\n                return;\n            }\n            this.walk.base[node.type](node, state, c);\n            if (isRequire(node) && node.arguments.length > 0) {\n                if (node.arguments[0].type === \"Literal\") {\n                    if (!lodash.isString(node.arguments[0].value)) {\n                        this.log.error(\"Unexpected literal value: %s%sRequired by: %s\",\n                            node.arguments[0].value, os.EOL, bundleItem.filename);\n                    }\n                    moduleNames.push(node.arguments[0].value);\n                }\n                else {\n                    expressions.push(node.arguments[0]);\n                }\n            }\n        };\n\n        if (bundleItem.ast) {\n            this.walk.recursive(bundleItem.ast, null, {\n                Expression: visitNode,\n                Statement: visitNode\n            });\n        }\n\n        this.addDynamicDependencies(expressions, bundleItem, (dynamicDependencies) => {\n            onDependenciesCollected(moduleNames.concat(dynamicDependencies));\n        });\n    }\n\n    private collectAmbientModules(queue: Queued[]): string[] {\n\n        const ambientModuleNames: string[] = [];\n\n        queue.forEach((queued) => {\n            if (queued.emitOutput.ambientModuleNames) {\n                ambientModuleNames.push(...queued.emitOutput.ambientModuleNames);\n            }\n        });\n\n        return ambientModuleNames;\n    }\n\n    private addBundleItem(queued: Queued, resolvedModule: any, moduleName: string, ambientModuleNames: string[]) {\n        if (ambientModuleNames.indexOf(moduleName) === -1) {\n            queued.item.dependencies.push(\n                new BundleItem(moduleName, resolvedModule && resolvedModule.resolvedFileName)\n            );\n        }\n    }\n\n    private findUnresolvedTsRequires(emitOutput: EmitOutput): BundleItem[] {\n\n        const dependencies: BundleItem[] = [];\n\n        if (emitOutput.isDeclarationFile) {\n            return dependencies;\n        }\n\n        const visitNode = (node: ts.Node) => {\n\n            if (node.kind === ts.SyntaxKind.CallExpression) {\n\n                const ce = (node as ts.CallExpression);\n\n                const expression = ce.expression ?\n                    (ce.expression as ts.LiteralExpression) :\n                    undefined;\n\n                const argument = ce.arguments && ce.arguments.length ?\n                    (ce.arguments[0] as ts.LiteralExpression) :\n                    undefined;\n\n                if (expression && expression.text === \"require\" &&\n                    argument && typeof argument.text === \"string\") {\n                    dependencies.push(new BundleItem(argument.text));\n                }\n            }\n\n            ts.forEachChild(node, visitNode);\n        };\n\n        visitNode(emitOutput.sourceFile);\n\n        return dependencies;\n    }\n\n    private addDynamicDependencies(expressions: any[],\n                                   bundleItem: BundleItem,\n                                   onDynamicDependenciesAdded: (dynamicDependencies: string[]) => void) {\n\n        const dynamicDependencies: string[] = [];\n\n        if (expressions.length === 0) {\n            process.nextTick(() => {\n                onDynamicDependenciesAdded(dynamicDependencies);\n            });\n            return;\n        }\n\n        async.each(expressions, (expression, onExpressionResolved) => {\n\n            const dynamicModuleName = this.parseDynamicRequire(expression);\n            const directory = path.dirname(bundleItem.filename);\n            let pattern: string;\n\n            if (dynamicModuleName && dynamicModuleName !== \"*\") {\n                if (new BundleItem(dynamicModuleName).isNpmModule()) {\n                    dynamicDependencies.push(dynamicModuleName);\n                    onExpressionResolved();\n                }\n                else {\n                    pattern = path.join(directory, dynamicModuleName);\n                    glob(pattern, (globError, matches) => {\n                        if (globError) {\n                            throw globError;\n                        }\n                        async.each(matches, (match, onMatchResolved) => {\n                            fs.stat(match, (statError, stats) => {\n                                if (statError) {\n                                    throw statError;\n                                }\n                                if (stats.isFile()) {\n                                    this.log.debug(\"Dynamic require: \\nexpression: [%s]\" +\n                                                  \"\\nfilename: %s\\nrequired by %s\\nglob: %s\",\n                                                  JSON.stringify(expression, undefined, 3),\n                                                  match, bundleItem.filename, pattern);\n                                    dynamicDependencies.push(\"./\" + path.relative(directory, match));\n                                }\n                                onMatchResolved();\n                            });\n                        }, onExpressionResolved);\n                    });\n                }\n            }\n            else {\n                onExpressionResolved();\n            }\n        }, () => {\n            onDynamicDependenciesAdded(dynamicDependencies);\n        });\n    }\n\n    private parseDynamicRequire(expression: any): string {\n\n        const visitNode = (node: any): string => {\n            switch (node.type) {\n                case \"BinaryExpression\":\n                    if (node.operator === \"+\") {\n                        return visitNode(node.left) + visitNode(node.right);\n                    }\n                    break;\n                case \"ExpressionStatement\":\n                    return visitNode(node.expression);\n                case \"Literal\":\n                    return node.value + \"\";\n                case \"Identifier\":\n                    return \"*\";\n                default:\n                    return \"\";\n            }\n        };\n\n        return visitNode(expression);\n    }\n\n    private validateCase(queue: Queued[]) {\n\n        const files = queue.map((q) => {\n            return q.file.originalPath;\n        });\n\n        const fileslower = queue.map((q) => {\n            return q.file.originalPath.toLowerCase();\n        });\n\n        queue.forEach((queued) => {\n            if (queued.item.dependencies) {\n                queued.item.dependencies.forEach((dependency) => {\n                    if (dependency.filename && files.indexOf(dependency.filename) === -1) {\n                        const lowerIndex = fileslower.indexOf(dependency.filename.toLowerCase());\n                        if (lowerIndex !== -1) {\n\n                            const result = diff.diffChars(files[lowerIndex], dependency.filename);\n                            let arrows = \"\";\n                            result.forEach((part) => {\n                                if (part.added) {\n                                    arrows += \"^\";\n                                }\n                                else if (!part.removed){\n                                    arrows += pad(\"\", part.count);\n                                }\n                            });\n\n                            throw new Error(\"Uppercase/lowercase mismatch importing \" +\n                                dependency.moduleName + \" from \" + queued.file.originalPath +\n                                \":\" + os.EOL + os.EOL +\n                                \"filename:    \" + files[lowerIndex] + os.EOL +\n                                \"module name: \" + dependency.filename + os.EOL +\n                                \"             \" + arrows + os.EOL);\n                        }\n                    }\n                });\n            }\n        });\n    }\n}\n"]}