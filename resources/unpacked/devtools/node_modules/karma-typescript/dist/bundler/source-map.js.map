{"version":3,"file":"source-map.js","sourceRoot":"","sources":["../../src/bundler/source-map.ts"],"names":[],"mappings":";;AAAA,qDAAuD;AACvD,qDAAuD;AACvD,uBAAyB;AACzB,2BAA6B;AAO7B;IAKI,mBAAoB,MAAqB,EAAU,GAAW;QAA1C,WAAM,GAAN,MAAM,CAAe;QAAU,QAAG,GAAH,GAAG,CAAQ;QAFtD,SAAI,GAAW,CAAC,CAAC;IAEwC,CAAC;IAE3D,8BAAU,GAAjB,UAAkB,MAAc;QAC5B,IAAI,CAAC,QAAQ,GAAG,gBAAgB,CAAC,MAAM,EAAE,CAAC;QAC1C,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC;IACjD,CAAC;IAEM,0CAAsB,GAA7B,UAA8B,MAAc;QACxC,OAAO,MAAM,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;YACpC,gBAAgB,CAAC,cAAc,CAAC,MAAM,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC;YAC/D,MAAM,CAAC,UAAU,CAAC,UAAU,CAAC;IACrC,CAAC;IAEM,gCAAY,GAAnB,UAAoB,MAAc;QAC9B,IAAI,MAAM,CAAC,UAAU,CAAC,aAAa,EAAE;YAEjC,IAAM,GAAG,GAAG,gBAAgB,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;YACvE,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,gBAAgB,CAAC,EAAE;gBACpC,GAAG,CAAC,WAAW,CAAC,gBAAgB,EAAE,CAAC,MAAM,CAAC,UAAU,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC;aAC1E;YAED,OAAO,GAAG,CAAC;SACd;QAED,OAAO,SAAS,CAAC;IACrB,CAAC;IAEM,2BAAO,GAAd,UAAe,UAAsB;QAEjC,IAAI,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,SAAS,EAAE;YAEtC,IAAI,CAAC,mBAAmB,CAAC,UAAU,CAAC,CAAC;YAErC,IAAM,UAAU,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,UAAU,CAAC,QAAQ,CAAC,CAAC;YAClF,IAAI,CAAC,QAAQ,CAAC,OAAO,CACjB,EAAE,UAAU,EAAE,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,UAAU,CAAC,EAAE,MAAM,EAAE,UAAU,CAAC,MAAM,EAAE,EACzE,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,CACtB,CAAC;SACL;QAED,UAAU,CAAC,MAAM,GAAG,gBAAgB,CAAC,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;IAC3E,CAAC;IAEM,oCAAgB,GAAvB,UAAwB,aAAqB;QACzC,IAAI,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,SAAS,EAAE;YACtC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,mBAAmB,CAAC,aAAa,CAAC,CAAC;SACxD;IACL,CAAC;IAEM,8BAAU,GAAjB;QACI,OAAO,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;IAC/E,CAAC;IAEM,uCAAmB,GAA1B,UAA2B,UAAsB;QAAjD,iBAgDC;QA9CG,IAAM,YAAY,GAAG,gBAAgB,CAAC,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;QAElF,IAAI,YAAY,IAAI,YAAY,CAAC,CAAC,CAAC,EAAE;YAEjC,IAAI,GAAG,SAAqC,CAAC;YAC7C,IAAM,SAAO,GAAG,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;YAElD,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE;gBACtC,IAAM,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,SAAO,EAAE,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;gBACxD,IAAI;oBACA,IAAM,OAAO,GAAG,EAAE,CAAC,YAAY,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;oBACtD,GAAG,GAAG,gBAAgB,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;iBAC5C;gBACD,OAAO,KAAK,EAAE;oBACV,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,6BAA6B,EAAE,WAAW,CAAC,CAAC;iBAC9D;aACJ;iBACI;gBACD,GAAG,GAAG,gBAAgB,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;aACvD;YAED,IAAI,CAAC,GAAG,EAAE;gBACN,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,qCAAqC,EAAE,UAAU,CAAC,QAAQ,CAAC,CAAC;gBAC3E,OAAO;aACV;YAED,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,gBAAgB,CAAC,EAAE;gBAEpC,IAAM,gBAAc,GAAa,EAAE,CAAC;gBACpC,GAAG,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC,UAAC,MAAc;oBAC9C,IAAM,cAAc,GAAG,IAAI,CAAC,IAAI,CAAC,SAAO,EAAE,MAAM,CAAC,CAAC;oBAClD,IAAI;wBACA,IAAM,aAAa,GAAG,EAAE,CAAC,YAAY,CAAC,cAAc,EAAE,OAAO,CAAC,CAAC;wBAC/D,gBAAc,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;qBACtC;oBACD,OAAO,KAAK,EAAE;wBACV,KAAI,CAAC,GAAG,CAAC,KAAK,CAAC,8BAA8B,EAAE,cAAc,CAAC,CAAC;qBAClE;gBACL,CAAC,CAAC,CAAC;gBACH,GAAG,CAAC,WAAW,CAAC,gBAAgB,EAAE,gBAAc,CAAC,CAAC;aACrD;YAED,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC;YAEzB,UAAU,CAAC,MAAM,GAAG,gBAAgB,CAAC,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC,SAAS,EAAE,CAAC;SAC5F;IACL,CAAC;IAEO,kCAAc,GAAtB,UAAuB,GAAwC;QAC3D,GAAG,CAAC,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC,UAAC,MAAc,EAAE,KAAa;YACxD,GAAG,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,MAAM,CAAC,OAAO,CAAC,aAAa,EAAE,EAAE,CAAC,CAAC;QACrE,CAAC,CAAC,CAAC;IACP,CAAC;IAEO,uCAAmB,GAA3B,UAA4B,MAAW;QACnC,IAAM,QAAQ,GAAG,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QACrC,OAAO,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IAC1C,CAAC;IACL,gBAAC;AAAD,CAAC,AAtHD,IAsHC;AAtHY,8BAAS","sourcesContent":["import * as combineSourceMap from \"combine-source-map\";\nimport * as convertSourceMap from \"convert-source-map\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\n\nimport { Logger } from \"log4js\";\nimport { Configuration } from \"../shared/configuration\";\nimport { BundleItem } from \"./bundle-item\";\nimport { Queued } from \"./queued\";\n\nexport class SourceMap {\n\n    private combiner: Combiner;\n    private line: number = 0;\n\n    constructor(private config: Configuration, private log: Logger) {}\n\n    public initialize(bundle: string) {\n        this.combiner = combineSourceMap.create();\n        this.line = this.getNumberOfNewlines(bundle);\n    }\n\n    public removeSourceMapComment(queued: Queued): string {\n        return queued.emitOutput.sourceMapText ?\n            combineSourceMap.removeComments(queued.emitOutput.outputText) :\n            queued.emitOutput.outputText;\n    }\n\n    public getSourceMap(queued: Queued): convertSourceMap.SourceMapConverter {\n        if (queued.emitOutput.sourceMapText) {\n\n            const map = convertSourceMap.fromJSON(queued.emitOutput.sourceMapText);\n            if (!map.getProperty(\"sourcesContent\")) {\n                map.addProperty(\"sourcesContent\", [queued.emitOutput.sourceFile.text]);\n            }\n\n            return map;\n        }\n\n        return undefined;\n    }\n\n    public addFile(bundleItem: BundleItem) {\n\n        if (this.config.bundlerOptions.sourceMap) {\n\n            this.loadFileFromComment(bundleItem);\n\n            const sourceFile = path.relative(this.config.karma.basePath, bundleItem.filename);\n            this.combiner.addFile(\n                { sourceFile: path.join(\"/base\", sourceFile), source: bundleItem.source },\n                { line: this.line }\n            );\n        }\n\n        bundleItem.source = combineSourceMap.removeComments(bundleItem.source);\n    }\n\n    public offsetLineNumber(wrappedSource: string) {\n        if (this.config.bundlerOptions.sourceMap) {\n            this.line += this.getNumberOfNewlines(wrappedSource);\n        }\n    }\n\n    public getComment() {\n        return this.config.bundlerOptions.sourceMap ? this.combiner.comment() : \"\";\n    }\n\n    public loadFileFromComment(bundleItem: BundleItem) {\n\n        const commentMatch = convertSourceMap.mapFileCommentRegex.exec(bundleItem.source);\n\n        if (commentMatch && commentMatch[1]) {\n\n            let map: convertSourceMap.SourceMapConverter;\n            const dirname = path.dirname(bundleItem.filename);\n\n            if (!commentMatch[1].startsWith(\"data:\")) {\n                const mapFilename = path.join(dirname, commentMatch[1]);\n                try {\n                    const mapJson = fs.readFileSync(mapFilename, \"utf-8\");\n                    map = convertSourceMap.fromJSON(mapJson);\n                }\n                catch (error) {\n                    this.log.debug(\"Source map %s doesn't exist\", mapFilename);\n                }\n            }\n            else {\n                map = convertSourceMap.fromComment(commentMatch[0]);\n            }\n\n            if (!map) {\n                this.log.debug(\"Unable to resolve source map for %s\", bundleItem.filename);\n                return;\n            }\n\n            if (!map.getProperty(\"sourcesContent\")) {\n\n                const sourcesContent: string[] = [];\n                map.getProperty(\"sources\").forEach((source: string) => {\n                    const sourceFilename = path.join(dirname, source);\n                    try {\n                        const sourceContent = fs.readFileSync(sourceFilename, \"utf-8\");\n                        sourcesContent.push(sourceContent);\n                    }\n                    catch (error) {\n                        this.log.debug(\"Source file %s doesn't exist\", sourceFilename);\n                    }\n                });\n                map.addProperty(\"sourcesContent\", sourcesContent);\n            }\n\n            this.cleanupSources(map);\n\n            bundleItem.source = combineSourceMap.removeComments(bundleItem.source) + map.toComment();\n        }\n    }\n\n    private cleanupSources(map: convertSourceMap.SourceMapConverter) {\n        map.sourcemap.sources.forEach((source: string, index: number) => {\n            map.sourcemap.sources[index] = source.replace(\"webpack:///\", \"\");\n        });\n    }\n\n    private getNumberOfNewlines(source: any) {\n        const newlines = source.match(/\\n/g);\n        return newlines ? newlines.length : 0;\n    }\n}\n"]}