#!/usr/bin/env node

/*
  @license
	Rollup.js v2.3.3
	Sat, 04 Apr 2020 22:17:48 GMT - commit d18cb37d7c328a63c36761583ce456275f164462


	https://github.com/rollup/rollup

	Released under the MIT License.
*/
'use strict';

function _interopNamespace(e) {
  if (e && e.__esModule) { return e; } else {
    var n = {};
    if (e) {
      Object.keys(e).forEach(function (k) {
        n[k] =e [k];
      });
    }
    n['default'] = e;
    return n;
  }
}

var rollup_js = require('../shared/rollup.js');
var path = require('path');
require('crypto');
var fs = require('fs');
require('events');
require('util');
var _events_commonjsExternal = require('../shared/_events_commonjs-external.js');
var mergeOptions = require('../shared/mergeOptions.js');
var commandPlugins = require('../shared/commandPlugins.js');
var module$1 = require('module');
var url = require('url');
var assert = require('assert');

var help = "rollup version __VERSION__\r\n=====================================\r\n\r\nUsage: rollup [options] <entry file>\r\n\r\nBasic options:\r\n\r\n-c, --config <filename>     Use this config file (if argument is used but value\r\n                              is unspecified, defaults to rollup.config.js)\r\n-d, --dir <dirname>         Directory for chunks (if absent, prints to stdout)\r\n-e, --external <ids>        Comma-separate list of module IDs to exclude\r\n-f, --format <format>       Type of output (amd, cjs, es, iife, umd, system)\r\n-g, --globals <pairs>       Comma-separate list of `moduleID:Global` pairs\r\n-h, --help                  Show this help message\r\n-i, --input <filename>      Input (alternative to <entry file>)\r\n-m, --sourcemap             Generate sourcemap (`-m inline` for inline map)\r\n-n, --name <name>           Name for UMD export\r\n-o, --file <output>         Single output file (if absent, prints to stdout)\r\n-p, --plugin <plugin>       Use the plugin specified (may be repeated)\r\n-v, --version               Show version number\r\n-w, --watch                 Watch files in bundle and rebuild on changes\r\n--amd.id <id>               ID for AMD module (default is anonymous)\r\n--amd.define <name>         Function to use in place of `define`\r\n--assetFileNames <pattern>  Name pattern for emitted assets\r\n--banner <text>             Code to insert at top of bundle (outside wrapper)\r\n--chunkFileNames <pattern>  Name pattern for emitted secondary chunks\r\n--compact                   Minify wrapper code\r\n--context <variable>        Specify top-level `this` value\r\n--entryFileNames <pattern>  Name pattern for emitted entry chunks\r\n--environment <values>      Settings passed to config file (see example)\r\n--no-esModule               Do not add __esModule property\r\n--exports <mode>            Specify export mode (auto, default, named, none)\r\n--extend                    Extend global variable defined by --name\r\n--no-externalLiveBindings   Do not generate code to support live bindings\r\n--footer <text>             Code to insert at end of bundle (outside wrapper)\r\n--no-freeze                 Do not freeze namespace objects\r\n--no-hoistTransitiveImports Do not hoist transitive imports into entry chunks\r\n--no-indent                 Don't indent result\r\n--no-interop                Do not include interop block\r\n--inlineDynamicImports      Create single bundle when using dynamic imports\r\n--intro <text>              Code to insert at top of bundle (inside wrapper)\r\n--namespaceToStringTag      Create proper `.toString` methods for namespaces\r\n--noConflict                Generate a noConflict method for UMD globals\r\n--no-strict                 Don't emit `\"use strict\";` in the generated modules\r\n--outro <text>              Code to insert at end of bundle (inside wrapper)\r\n--preferConst               Use `const` instead of `var` for exports\r\n--preserveModules           Preserve module structure\r\n--preserveSymlinks          Do not follow symlinks when resolving files\r\n--shimMissingExports        Create shim variables for missing exports\r\n--silent                    Don't print warnings\r\n--sourcemapExcludeSources   Do not include source code in source maps\r\n--sourcemapFile <file>      Specify bundle position for source maps\r\n--no-stdin                  do not read \"-\" from stdin\r\n--strictDeprecations        Throw errors for deprecated features\r\n--no-treeshake              Disable tree-shaking optimisations\r\n--no-treeshake.annotations  Ignore pure call annotations\r\n--no-treeshake.propertyReadSideEffects Ignore property access side-effects\r\n\r\nExamples:\r\n\r\n# use settings in config file\r\nrollup -c\r\n\r\n# in config file, process.env.INCLUDE_DEPS === 'true'\r\n# and process.env.BUILD === 'production'\r\nrollup -c --environment INCLUDE_DEPS,BUILD:production\r\n\r\n# create CommonJS bundle.js from src/main.js\r\nrollup --format=cjs --file=bundle.js -- src/main.js\r\n\r\n# create self-executing IIFE using `window.jQuery`\r\n# and `window._` as external globals\r\nrollup -f iife --globals jquery:jQuery,lodash:_ \\\r\n  -i src/app.js -o build/app.js -m build/app.js.map\r\n\r\nNotes:\r\n\r\n* When piping to stdout, only inline sourcemaps are permitted\r\n\r\nFor more information visit https://rollupjs.org\r\n";

const preserveCamelCase = string => {
	let isLastCharLower = false;
	let isLastCharUpper = false;
	let isLastLastCharUpper = false;

	for (let i = 0; i < string.length; i++) {
		const character = string[i];

		if (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {
			string = string.slice(0, i) + '-' + string.slice(i);
			isLastCharLower = false;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = true;
			i++;
		} else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {
			string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = false;
			isLastCharLower = true;
		} else {
			isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
		}
	}

	return string;
};

const camelCase = (input, options) => {
	if (!(typeof input === 'string' || Array.isArray(input))) {
		throw new TypeError('Expected the input to be `string | string[]`');
	}

	options = Object.assign({
		pascalCase: false
	}, options);

	const postProcess = x => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;

	if (Array.isArray(input)) {
		input = input.map(x => x.trim())
			.filter(x => x.length)
			.join('-');
	} else {
		input = input.trim();
	}

	if (input.length === 0) {
		return '';
	}

	if (input.length === 1) {
		return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
	}

	const hasUpperCase = input !== input.toLowerCase();

	if (hasUpperCase) {
		input = preserveCamelCase(input);
	}

	input = input
		.replace(/^[_.\- ]+/, '')
		.toLowerCase()
		.replace(/[_.\- ]+(\w|$)/g, (_, p1) => p1.toUpperCase())
		.replace(/\d+(\w|$)/g, m => m.toUpperCase());

	return postProcess(input);
};

var camelcase = camelCase;
// TODO: Remove this for the next major release
var default_1 = camelCase;
camelcase.default = default_1;

var decamelize = function (str, sep) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	sep = typeof sep === 'undefined' ? '_' : sep;

	return str
		.replace(/([a-z\d])([A-Z])/g, '$1' + sep + '$2')
		.replace(/([A-Z]+)([A-Z][a-z\d]+)/g, '$1' + sep + '$2')
		.toLowerCase();
};

// take an un-split argv string and tokenize it.
var tokenizeArgString = function (argString) {
  if (Array.isArray(argString)) {
    return argString.map(e => typeof e !== 'string' ? e + '' : e)
  }

  argString = argString.trim();

  let i = 0;
  let prevC = null;
  let c = null;
  let opening = null;
  const args = [];

  for (let ii = 0; ii < argString.length; ii++) {
    prevC = c;
    c = argString.charAt(ii);

    // split on spaces unless we're in quotes.
    if (c === ' ' && !opening) {
      if (!(prevC === ' ')) {
        i++;
      }
      continue
    }

    // don't split the string if we're in matching
    // opening or closing single and double quotes.
    if (c === opening) {
      opening = null;
    } else if ((c === "'" || c === '"') && !opening) {
      opening = c;
    }

    if (!args[i]) args[i] = '';
    args[i] += c;
  }

  return args
};

function parse (args, opts) {
  opts = Object.assign(Object.create(null), opts);
  // allow a string argument to be passed in rather
  // than an argv array.
  args = tokenizeArgString(args);

  // aliases might have transitive relationships, normalize this.
  const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
  const configuration = Object.assign({
    'boolean-negation': true,
    'camel-case-expansion': true,
    'combine-arrays': false,
    'dot-notation': true,
    'duplicate-arguments-array': true,
    'flatten-duplicate-arrays': true,
    'greedy-arrays': true,
    'halt-at-non-option': false,
    'nargs-eats-options': false,
    'negation-prefix': 'no-',
    'parse-numbers': true,
    'populate--': false,
    'set-placeholder-key': false,
    'short-option-groups': true,
    'strip-aliased': false,
    'strip-dashed': false,
    'unknown-options-as-args': false
  }, opts.configuration);
  const defaults = Object.assign(Object.create(null), opts.default);
  const configObjects = opts.configObjects || [];
  const envPrefix = opts.envPrefix;
  const notFlagsOption = configuration['populate--'];
  const notFlagsArgv = notFlagsOption ? '--' : '_';
  const newAliases = Object.create(null);
  const defaulted = Object.create(null);
  // allow a i18n handler to be passed in, default to a fake one (util.format).
  const __ = opts.__ || _events_commonjsExternal.require$$1.format;
  const flags = {
    aliases: Object.create(null),
    arrays: Object.create(null),
    bools: Object.create(null),
    strings: Object.create(null),
    numbers: Object.create(null),
    counts: Object.create(null),
    normalize: Object.create(null),
    configs: Object.create(null),
    nargs: Object.create(null),
    coercions: Object.create(null),
    keys: []
  };
  const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
  const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)')

  ;[].concat(opts.array).filter(Boolean).forEach(function (opt) {
    const key = opt.key || opt;

    // assign to flags[bools|strings|numbers]
    const assignment = Object.keys(opt).map(function (key) {
      return ({
        boolean: 'bools',
        string: 'strings',
        number: 'numbers'
      })[key]
    }).filter(Boolean).pop();

    // assign key to be coerced
    if (assignment) {
      flags[assignment][key] = true;
    }

    flags.arrays[key] = true;
    flags.keys.push(key);
  })

  ;[].concat(opts.boolean).filter(Boolean).forEach(function (key) {
    flags.bools[key] = true;
    flags.keys.push(key);
  })

  ;[].concat(opts.string).filter(Boolean).forEach(function (key) {
    flags.strings[key] = true;
    flags.keys.push(key);
  })

  ;[].concat(opts.number).filter(Boolean).forEach(function (key) {
    flags.numbers[key] = true;
    flags.keys.push(key);
  })

  ;[].concat(opts.count).filter(Boolean).forEach(function (key) {
    flags.counts[key] = true;
    flags.keys.push(key);
  })

  ;[].concat(opts.normalize).filter(Boolean).forEach(function (key) {
    flags.normalize[key] = true;
    flags.keys.push(key);
  });

  Object.keys(opts.narg || {}).forEach(function (k) {
    flags.nargs[k] = opts.narg[k];
    flags.keys.push(k);
  });

  Object.keys(opts.coerce || {}).forEach(function (k) {
    flags.coercions[k] = opts.coerce[k];
    flags.keys.push(k);
  });

  if (Array.isArray(opts.config) || typeof opts.config === 'string') {
[].concat(opts.config).filter(Boolean).forEach(function (key) {
      flags.configs[key] = true;
    });
  } else {
    Object.keys(opts.config || {}).forEach(function (k) {
      flags.configs[k] = opts.config[k];
    });
  }

  // create a lookup table that takes into account all
  // combinations of aliases: {f: ['foo'], foo: ['f']}
  extendAliases(opts.key, aliases, opts.default, flags.arrays);

  // apply default values to all aliases.
  Object.keys(defaults).forEach(function (key) {
    (flags.aliases[key] || []).forEach(function (alias) {
      defaults[alias] = defaults[key];
    });
  });

  let error = null;
  checkConfiguration();

  let notFlags = [];

  const argv = Object.assign(Object.create(null), { _: [] });
  // TODO(bcoe): for the first pass at removing object prototype  we didn't
  // remove all prototypes from objects returned by this API, we might want
  // to gradually move towards doing so.
  const argvReturn = {};

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    let broken;
    let key;
    let letters;
    let m;
    let next;
    let value;

    // any unknown option (except for end-of-options, "--")
    if (arg !== '--' && isUnknownOptionAsArg(arg)) {
      argv._.push(arg);
    // -- separated by =
    } else if (arg.match(/^--.+=/) || (
      !configuration['short-option-groups'] && arg.match(/^-.+=/)
    )) {
      // Using [\s\S] instead of . because js doesn't support the
      // 'dotall' regex modifier. See:
      // http://stackoverflow.com/a/1068308/13216
      m = arg.match(/^--?([^=]+)=([\s\S]*)$/);

      // arrays format = '--f=a b c'
      if (checkAllAliases(m[1], flags.arrays)) {
        args.splice(i + 1, 0, m[2]);
        i = eatArray(i, m[1], args);
      } else if (checkAllAliases(m[1], flags.nargs)) {
        // nargs format = '--f=monkey washing cat'
        args.splice(i + 1, 0, m[2]);
        i = eatNargs(i, m[1], args);
      } else {
        setArg(m[1], m[2]);
      }
    } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {
      key = arg.match(negatedBoolean)[1];
      setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);

    // -- separated by space.
    } else if (arg.match(/^--.+/) || (
      !configuration['short-option-groups'] && arg.match(/^-[^-]+/)
    )) {
      key = arg.match(/^--?(.+)/)[1];

      if (checkAllAliases(key, flags.arrays)) {
        // array format = '--foo a b c'
        i = eatArray(i, key, args);
      } else if (checkAllAliases(key, flags.nargs) !== false) {
        // nargs format = '--foo a b c'
        // should be truthy even if: flags.nargs[key] === 0
        i = eatNargs(i, key, args);
      } else {
        next = args[i + 1];

        if (next !== undefined && (!next.match(/^-/) ||
          next.match(negative)) &&
          !checkAllAliases(key, flags.bools) &&
          !checkAllAliases(key, flags.counts)) {
          setArg(key, next);
          i++;
        } else if (/^(true|false)$/.test(next)) {
          setArg(key, next);
          i++;
        } else {
          setArg(key, defaultValue(key));
        }
      }

    // dot-notation flag separated by '='.
    } else if (arg.match(/^-.\..+=/)) {
      m = arg.match(/^-([^=]+)=([\s\S]*)$/);
      setArg(m[1], m[2]);

    // dot-notation flag separated by space.
    } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
      next = args[i + 1];
      key = arg.match(/^-(.\..+)/)[1];

      if (next !== undefined && !next.match(/^-/) &&
        !checkAllAliases(key, flags.bools) &&
        !checkAllAliases(key, flags.counts)) {
        setArg(key, next);
        i++;
      } else {
        setArg(key, defaultValue(key));
      }
    } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
      letters = arg.slice(1, -1).split('');
      broken = false;

      for (let j = 0; j < letters.length; j++) {
        next = arg.slice(j + 2);

        if (letters[j + 1] && letters[j + 1] === '=') {
          value = arg.slice(j + 3);
          key = letters[j];

          if (checkAllAliases(key, flags.arrays)) {
            // array format = '-f=a b c'
            args.splice(i + 1, 0, value);
            i = eatArray(i, key, args);
          } else if (checkAllAliases(key, flags.nargs)) {
            // nargs format = '-f=monkey washing cat'
            args.splice(i + 1, 0, value);
            i = eatNargs(i, key, args);
          } else {
            setArg(key, value);
          }

          broken = true;
          break
        }

        if (next === '-') {
          setArg(letters[j], next);
          continue
        }

        // current letter is an alphabetic character and next value is a number
        if (/[A-Za-z]/.test(letters[j]) &&
          /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
          setArg(letters[j], next);
          broken = true;
          break
        }

        if (letters[j + 1] && letters[j + 1].match(/\W/)) {
          setArg(letters[j], next);
          broken = true;
          break
        } else {
          setArg(letters[j], defaultValue(letters[j]));
        }
      }

      key = arg.slice(-1)[0];

      if (!broken && key !== '-') {
        if (checkAllAliases(key, flags.arrays)) {
          // array format = '-f a b c'
          i = eatArray(i, key, args);
        } else if (checkAllAliases(key, flags.nargs) !== false) {
          // nargs format = '-f a b c'
          // should be truthy even if: flags.nargs[key] === 0
          i = eatNargs(i, key, args);
        } else {
          next = args[i + 1];

          if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||
            next.match(negative)) &&
            !checkAllAliases(key, flags.bools) &&
            !checkAllAliases(key, flags.counts)) {
            setArg(key, next);
            i++;
          } else if (/^(true|false)$/.test(next)) {
            setArg(key, next);
            i++;
          } else {
            setArg(key, defaultValue(key));
          }
        }
      }
    } else if (arg.match(/^-[0-9]$/) &&
      arg.match(negative) &&
      checkAllAliases(arg.slice(1), flags.bools)) {
      // single-digit boolean alias, e.g: xargs -0
      key = arg.slice(1);
      setArg(key, defaultValue(key));
    } else if (arg === '--') {
      notFlags = args.slice(i + 1);
      break
    } else if (configuration['halt-at-non-option']) {
      notFlags = args.slice(i);
      break
    } else {
      argv._.push(maybeCoerceNumber('_', arg));
    }
  }

  // order of precedence:
  // 1. command line arg
  // 2. value from env var
  // 3. value from config file
  // 4. value from config objects
  // 5. configured default value
  applyEnvVars(argv, true); // special case: check env vars that point to config file
  applyEnvVars(argv, false);
  setConfig(argv);
  setConfigObjects();
  applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
  applyCoercions(argv);
  if (configuration['set-placeholder-key']) setPlaceholderKeys(argv);

  // for any counts either not in args or without an explicit default, set to 0
  Object.keys(flags.counts).forEach(function (key) {
    if (!hasKey(argv, key.split('.'))) setArg(key, 0);
  });

  // '--' defaults to undefined.
  if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = [];
  notFlags.forEach(function (key) {
    argv[notFlagsArgv].push(key);
  });

  if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {
    Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {
      delete argv[key];
    });
  }

  if (configuration['strip-aliased']) {
[].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {
      if (configuration['camel-case-expansion']) {
        delete argv[alias.split('.').map(prop => camelcase(prop)).join('.')];
      }

      delete argv[alias];
    });
  }

  // how many arguments should we consume, based
  // on the nargs option?
  function eatNargs (i, key, args) {
    let ii;
    let toEat = checkAllAliases(key, flags.nargs);
    // NaN has a special meaning for the array type, indicating that one or
    // more values are expected.
    toEat = isNaN(toEat) ? 1 : toEat;

    if (toEat === 0) {
      setArg(key, defaultValue(key));
      return i
    }

    let available = 0;
    if (configuration['nargs-eats-options']) {
      // classic behavior, yargs eats positional and dash arguments.
      if (args.length - (i + 1) < toEat) error = Error(__('Not enough arguments following: %s', key));
      available = toEat;
    } else {
      // nargs will not consume flag arguments, e.g., -abc, --foo,
      // and terminates when one is observed.
      for (ii = i + 1; ii < args.length; ii++) {
        if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii])) available++;
        else break
      }
      if (available < toEat) error = Error(__('Not enough arguments following: %s', key));
    }

    const consumed = Math.min(available, toEat);
    for (ii = i + 1; ii < (consumed + i + 1); ii++) {
      setArg(key, args[ii]);
    }

    return (i + consumed)
  }

  // if an option is an array, eat all non-hyphenated arguments
  // following it... YUM!
  // e.g., --foo apple banana cat becomes ["apple", "banana", "cat"]
  function eatArray (i, key, args) {
    let argsToSet = [];
    let next = args[i + 1];
    // If both array and nargs are configured, enforce the nargs count:
    const nargsCount = checkAllAliases(key, flags.nargs);

    if (checkAllAliases(key, flags.bools) && !(/^(true|false)$/.test(next))) {
      argsToSet.push(true);
    } else if (isUndefined(next) || (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))) {
      // for keys without value ==> argsToSet remains an empty []
      // set user default value, if available
      if (defaults[key] !== undefined) {
        const defVal = defaults[key];
        argsToSet = Array.isArray(defVal) ? defVal : [defVal];
      }
    } else {
      for (let ii = i + 1; ii < args.length; ii++) {
        next = args[ii];
        if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break
        i = ii;
        argsToSet.push(processValue(key, next));
        if (!configuration['greedy-arrays'] ||
            (nargsCount && argsToSet.length >= nargsCount)) break
      }
    }

    // If both array and nargs are configured, create an error if less than
    // nargs positionals were found. NaN has special meaning, indicating
    // that at least one value is required (more are okay).
    if ((nargsCount && argsToSet.length < nargsCount) ||
        (isNaN(nargsCount) && argsToSet.length === 0)) {
      error = Error(__('Not enough arguments following: %s', key));
    }

    setArg(key, argsToSet);
    return i
  }

  function setArg (key, val) {
    if (/-/.test(key) && configuration['camel-case-expansion']) {
      const alias = key.split('.').map(function (prop) {
        return camelcase(prop)
      }).join('.');
      addNewAlias(key, alias);
    }

    const value = processValue(key, val);
    const splitKey = key.split('.');
    setKey(argv, splitKey, value);

    // handle populating aliases of the full key
    if (flags.aliases[key]) {
      flags.aliases[key].forEach(function (x) {
        x = x.split('.');
        setKey(argv, x, value);
      });
    }

    // handle populating aliases of the first element of the dot-notation key
    if (splitKey.length > 1 && configuration['dot-notation']) {
(flags.aliases[splitKey[0]] || []).forEach(function (x) {
        x = x.split('.');

        // expand alias with nested objects in key
        const a = [].concat(splitKey);
        a.shift(); // nuke the old key.
        x = x.concat(a);

        setKey(argv, x, value);
      });
    }

    // Set normalize getter and setter when key is in 'normalize' but isn't an array
    if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
      const keys = [key].concat(flags.aliases[key] || []);
      keys.forEach(function (key) {
        Object.defineProperty(argvReturn, key, {
          enumerable: true,
          get () {
            return val
          },
          set (value) {
            val = typeof value === 'string' ? _events_commonjsExternal.sysPath.normalize(value) : value;
          }
        });
      });
    }
  }

  function addNewAlias (key, alias) {
    if (!(flags.aliases[key] && flags.aliases[key].length)) {
      flags.aliases[key] = [alias];
      newAliases[alias] = true;
    }
    if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
      addNewAlias(alias, key);
    }
  }

  function processValue (key, val) {
    // strings may be quoted, clean this up as we assign values.
    if (typeof val === 'string' &&
      (val[0] === "'" || val[0] === '"') &&
      val[val.length - 1] === val[0]
    ) {
      val = val.substring(1, val.length - 1);
    }

    // handle parsing boolean arguments --foo=true --bar false.
    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
      if (typeof val === 'string') val = val === 'true';
    }

    let value = Array.isArray(val)
      ? val.map(function (v) { return maybeCoerceNumber(key, v) })
      : maybeCoerceNumber(key, val);

    // increment a count given as arg (either no value or value parsed as boolean)
    if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {
      value = increment;
    }

    // Set normalized value when key is in 'normalize' and in 'arrays'
    if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
      if (Array.isArray(val)) value = val.map(_events_commonjsExternal.sysPath.normalize);
      else value = _events_commonjsExternal.sysPath.normalize(val);
    }
    return value
  }

  function maybeCoerceNumber (key, value) {
    if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
      const shouldCoerceNumber = isNumber(value) && configuration['parse-numbers'] && (
        Number.isSafeInteger(Math.floor(value))
      );
      if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) value = Number(value);
    }
    return value
  }

  // set args from config.json file, this should be
  // applied last so that defaults can be applied.
  function setConfig (argv) {
    const configLookup = Object.create(null);

    // expand defaults/aliases, in-case any happen to reference
    // the config.json file.
    applyDefaultsAndAliases(configLookup, flags.aliases, defaults);

    Object.keys(flags.configs).forEach(function (configKey) {
      const configPath = argv[configKey] || configLookup[configKey];
      if (configPath) {
        try {
          let config = null;
          const resolvedConfigPath = _events_commonjsExternal.sysPath.resolve(process.cwd(), configPath);

          if (typeof flags.configs[configKey] === 'function') {
            try {
              config = flags.configs[configKey](resolvedConfigPath);
            } catch (e) {
              config = e;
            }
            if (config instanceof Error) {
              error = config;
              return
            }
          } else {
            config = rollup_js.commonjsRequire();
          }

          setConfigObject(config);
        } catch (ex) {
          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath));
        }
      }
    });
  }

  // set args from config object.
  // it recursively checks nested objects.
  function setConfigObject (config, prev) {
    Object.keys(config).forEach(function (key) {
      const value = config[key];
      const fullKey = prev ? prev + '.' + key : key;

      // if the value is an inner object and we have dot-notation
      // enabled, treat inner objects in config the same as
      // heavily nested dot notations (foo.bar.apple).
      if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {
        // if the value is an object but not an array, check nested object
        setConfigObject(value, fullKey);
      } else {
        // setting arguments via CLI takes precedence over
        // values within the config file.
        if (!hasKey(argv, fullKey.split('.')) || (checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays'])) {
          setArg(fullKey, value);
        }
      }
    });
  }

  // set all config objects passed in opts
  function setConfigObjects () {
    if (typeof configObjects === 'undefined') return
    configObjects.forEach(function (configObject) {
      setConfigObject(configObject);
    });
  }

  function applyEnvVars (argv, configOnly) {
    if (typeof envPrefix === 'undefined') return

    const prefix = typeof envPrefix === 'string' ? envPrefix : '';
    Object.keys(process.env).forEach(function (envVar) {
      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {
        // get array of nested keys and convert them to camel case
        const keys = envVar.split('__').map(function (key, i) {
          if (i === 0) {
            key = key.substring(prefix.length);
          }
          return camelcase(key)
        });

        if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && !hasKey(argv, keys)) {
          setArg(keys.join('.'), process.env[envVar]);
        }
      }
    });
  }

  function applyCoercions (argv) {
    let coerce;
    const applied = new Set();
    Object.keys(argv).forEach(function (key) {
      if (!applied.has(key)) { // If we haven't already coerced this option via one of its aliases
        coerce = checkAllAliases(key, flags.coercions);
        if (typeof coerce === 'function') {
          try {
            const value = maybeCoerceNumber(key, coerce(argv[key]))
            ;([].concat(flags.aliases[key] || [], key)).forEach(ali => {
              applied.add(ali);
              argv[ali] = value;
            });
          } catch (err) {
            error = err;
          }
        }
      }
    });
  }

  function setPlaceholderKeys (argv) {
    flags.keys.forEach((key) => {
      // don't set placeholder keys for dot notation options 'foo.bar'.
      if (~key.indexOf('.')) return
      if (typeof argv[key] === 'undefined') argv[key] = undefined;
    });
    return argv
  }

  function applyDefaultsAndAliases (obj, aliases, defaults, canLog = false) {
    Object.keys(defaults).forEach(function (key) {
      if (!hasKey(obj, key.split('.'))) {
        setKey(obj, key.split('.'), defaults[key]);
        if (canLog) defaulted[key] = true

        ;(aliases[key] || []).forEach(function (x) {
          if (hasKey(obj, x.split('.'))) return
          setKey(obj, x.split('.'), defaults[key]);
        });
      }
    });
  }

  function hasKey (obj, keys) {
    let o = obj;

    if (!configuration['dot-notation']) keys = [keys.join('.')];

    keys.slice(0, -1).forEach(function (key) {
      o = (o[key] || {});
    });

    const key = keys[keys.length - 1];

    if (typeof o !== 'object') return false
    else return key in o
  }

  function setKey (obj, keys, value) {
    let o = obj;

    if (!configuration['dot-notation']) keys = [keys.join('.')];

    keys.slice(0, -1).forEach(function (key, index) {
      // TODO(bcoe): in the next major version of yargs, switch to
      // Object.create(null) for dot notation:
      key = sanitizeKey(key);

      if (typeof o === 'object' && o[key] === undefined) {
        o[key] = {};
      }

      if (typeof o[key] !== 'object' || Array.isArray(o[key])) {
        // ensure that o[key] is an array, and that the last item is an empty object.
        if (Array.isArray(o[key])) {
          o[key].push({});
        } else {
          o[key] = [o[key], {}];
        }

        // we want to update the empty object at the end of the o[key] array, so set o to that object
        o = o[key][o[key].length - 1];
      } else {
        o = o[key];
      }
    });

    // TODO(bcoe): in the next major version of yargs, switch to
    // Object.create(null) for dot notation:
    const key = sanitizeKey(keys[keys.length - 1]);

    const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);
    const isValueArray = Array.isArray(value);
    let duplicate = configuration['duplicate-arguments-array'];

    // nargs has higher priority than duplicate
    if (!duplicate && checkAllAliases(key, flags.nargs)) {
      duplicate = true;
      if ((!isUndefined(o[key]) && flags.nargs[key] === 1) || (Array.isArray(o[key]) && o[key].length === flags.nargs[key])) {
        o[key] = undefined;
      }
    }

    if (value === increment) {
      o[key] = increment(o[key]);
    } else if (Array.isArray(o[key])) {
      if (duplicate && isTypeArray && isValueArray) {
        o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
      } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
        o[key] = value;
      } else {
        o[key] = o[key].concat([value]);
      }
    } else if (o[key] === undefined && isTypeArray) {
      o[key] = isValueArray ? value : [value];
    } else if (duplicate && !(
      o[key] === undefined ||
        checkAllAliases(key, flags.counts) ||
        checkAllAliases(key, flags.bools)
    )) {
      o[key] = [o[key], value];
    } else {
      o[key] = value;
    }
  }

  // extend the aliases list with inferred aliases.
  function extendAliases (...args) {
    args.forEach(function (obj) {
      Object.keys(obj || {}).forEach(function (key) {
        // short-circuit if we've already added a key
        // to the aliases array, for example it might
        // exist in both 'opts.default' and 'opts.key'.
        if (flags.aliases[key]) return

        flags.aliases[key] = [].concat(aliases[key] || []);
        // For "--option-name", also set argv.optionName
        flags.aliases[key].concat(key).forEach(function (x) {
          if (/-/.test(x) && configuration['camel-case-expansion']) {
            const c = camelcase(x);
            if (c !== key && flags.aliases[key].indexOf(c) === -1) {
              flags.aliases[key].push(c);
              newAliases[c] = true;
            }
          }
        });
        // For "--optionName", also set argv['option-name']
        flags.aliases[key].concat(key).forEach(function (x) {
          if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {
            const c = decamelize(x, '-');
            if (c !== key && flags.aliases[key].indexOf(c) === -1) {
              flags.aliases[key].push(c);
              newAliases[c] = true;
            }
          }
        });
        flags.aliases[key].forEach(function (x) {
          flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {
            return x !== y
          }));
        });
      });
    });
  }

  // return the 1st set flag for any of a key's aliases (or false if no flag set)
  function checkAllAliases (key, flag) {
    const toCheck = [].concat(flags.aliases[key] || [], key);
    const keys = Object.keys(flag);
    const setAlias = toCheck.find(key => keys.includes(key));
    return setAlias ? flag[setAlias] : false
  }

  function hasAnyFlag (key) {
    const toCheck = [].concat(Object.keys(flags).map(k => flags[k]));
    return toCheck.some(function (flag) {
      return Array.isArray(flag) ? flag.includes(key) : flag[key]
    })
  }

  function hasFlagsMatching (arg, ...patterns) {
    const toCheck = [].concat(...patterns);
    return toCheck.some(function (pattern) {
      const match = arg.match(pattern);
      return match && hasAnyFlag(match[1])
    })
  }

  // based on a simplified version of the short flag group parsing logic
  function hasAllShortFlags (arg) {
    // if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group
    if (arg.match(negative) || !arg.match(/^-[^-]+/)) { return false }
    let hasAllFlags = true;
    let next;
    const letters = arg.slice(1).split('');
    for (let j = 0; j < letters.length; j++) {
      next = arg.slice(j + 2);

      if (!hasAnyFlag(letters[j])) {
        hasAllFlags = false;
        break
      }

      if ((letters[j + 1] && letters[j + 1] === '=') ||
        next === '-' ||
        (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) ||
        (letters[j + 1] && letters[j + 1].match(/\W/))) {
        break
      }
    }
    return hasAllFlags
  }

  function isUnknownOptionAsArg (arg) {
    return configuration['unknown-options-as-args'] && isUnknownOption(arg)
  }

  function isUnknownOption (arg) {
    // ignore negative numbers
    if (arg.match(negative)) { return false }
    // if this is a short option group and all of them are configured, it isn't unknown
    if (hasAllShortFlags(arg)) { return false }
    // e.g. '--count=2'
    const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
    // e.g. '-a' or '--arg'
    const normalFlag = /^-+([^=]+?)$/;
    // e.g. '-a-'
    const flagEndingInHyphen = /^-+([^=]+?)-$/;
    // e.g. '-abc123'
    const flagEndingInDigits = /^-+([^=]+?\d+)$/;
    // e.g. '-a/usr/local'
    const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
    // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method
    return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters)
  }

  // make a best effor to pick a default value
  // for an option based on name and type.
  function defaultValue (key) {
    if (!checkAllAliases(key, flags.bools) &&
        !checkAllAliases(key, flags.counts) &&
        `${key}` in defaults) {
      return defaults[key]
    } else {
      return defaultForType(guessType(key))
    }
  }

  // return a default value, given the type of a flag.,
  // e.g., key of type 'string' will default to '', rather than 'true'.
  function defaultForType (type) {
    const def = {
      boolean: true,
      string: '',
      number: undefined,
      array: []
    };

    return def[type]
  }

  // given a flag, enforce a default type.
  function guessType (key) {
    let type = 'boolean';
    if (checkAllAliases(key, flags.strings)) type = 'string';
    else if (checkAllAliases(key, flags.numbers)) type = 'number';
    else if (checkAllAliases(key, flags.bools)) type = 'boolean';
    else if (checkAllAliases(key, flags.arrays)) type = 'array';
    return type
  }

  function isNumber (x) {
    if (x === null || x === undefined) return false
    // if loaded from config, may already be a number.
    if (typeof x === 'number') return true
    // hexadecimal.
    if (/^0x[0-9a-f]+$/i.test(x)) return true
    // don't treat 0123 as a number; as it drops the leading '0'.
    if (x.length > 1 && x[0] === '0') return false
    return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x)
  }

  function isUndefined (num) {
    return num === undefined
  }

  // check user configuration settings for inconsistencies
  function checkConfiguration () {
    // count keys should not be set as array/narg
    Object.keys(flags.counts).find(key => {
      if (checkAllAliases(key, flags.arrays)) {
        error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));
        return true
      } else if (checkAllAliases(key, flags.nargs)) {
        error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));
        return true
      }
    });
  }

  return {
    argv: Object.assign(argvReturn, argv),
    error: error,
    aliases: Object.assign({}, flags.aliases),
    newAliases: Object.assign({}, newAliases),
    defaulted: Object.assign({}, defaulted),
    configuration: configuration
  }
}

// if any aliases reference each other, we should
// merge them together.
function combineAliases (aliases) {
  const aliasArrays = [];
  const combined = Object.create(null);
  let change = true;

  // turn alias lookup hash {key: ['alias1', 'alias2']} into
  // a simple array ['key', 'alias1', 'alias2']
  Object.keys(aliases).forEach(function (key) {
    aliasArrays.push(
      [].concat(aliases[key], key)
    );
  });

  // combine arrays until zero changes are
  // made in an iteration.
  while (change) {
    change = false;
    for (let i = 0; i < aliasArrays.length; i++) {
      for (let ii = i + 1; ii < aliasArrays.length; ii++) {
        const intersect = aliasArrays[i].filter(function (v) {
          return aliasArrays[ii].indexOf(v) !== -1
        });

        if (intersect.length) {
          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
          aliasArrays.splice(ii, 1);
          change = true;
          break
        }
      }
    }
  }

  // map arrays back to the hash-lookup (de-dupe while
  // we're at it).
  aliasArrays.forEach(function (aliasArray) {
    aliasArray = aliasArray.filter(function (v, i, self) {
      return self.indexOf(v) === i
    });
    combined[aliasArray.pop()] = aliasArray;
  });

  return combined
}

// this function should only be called when a count is given as an arg
// it is NOT called to set a default value
// thus we can start the count at 1 instead of 0
function increment (orig) {
  return orig !== undefined ? orig + 1 : 1
}

function Parser (args, opts) {
  const result = parse(args.slice(), opts);
  return result.argv
}

// parse arguments and return detailed
// meta information, aliases, etc.
Parser.detailed = function (args, opts) {
  return parse(args.slice(), opts)
};

// TODO(bcoe): in the next major version of yargs, switch to
// Object.create(null) for dot notation:
function sanitizeKey (key) {
  if (key === '__proto__') return '___proto___'
  return key
}

var yargsParser = Parser;

var parseMs = milliseconds => {
	if (typeof milliseconds !== 'number') {
		throw new TypeError('Expected a number');
	}

	const roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil;

	return {
		days: roundTowardsZero(milliseconds / 86400000),
		hours: roundTowardsZero(milliseconds / 3600000) % 24,
		minutes: roundTowardsZero(milliseconds / 60000) % 60,
		seconds: roundTowardsZero(milliseconds / 1000) % 60,
		milliseconds: roundTowardsZero(milliseconds) % 1000,
		microseconds: roundTowardsZero(milliseconds * 1000) % 1000,
		nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1000
	};
};

const pluralize = (word, count) => count === 1 ? word : `${word}s`;

var prettyMs = (milliseconds, options = {}) => {
	if (!Number.isFinite(milliseconds)) {
		throw new TypeError('Expected a finite number');
	}

	if (options.colonNotation) {
		options.compact = false;
		options.formatSubMilliseconds = false;
		options.separateMilliseconds = false;
		options.verbose = false;
	}

	if (options.compact) {
		options.secondsDecimalDigits = 0;
		options.millisecondsDecimalDigits = 0;
	}

	const result = [];

	const add = (value, long, short, valueString) => {
		if ((result.length === 0 || !options.colonNotation) && value === 0 && !(options.colonNotation && short === 'm')) {
			return;
		}

		valueString = (valueString || value || '0').toString();
		let prefix;
		let suffix;
		if (options.colonNotation) {
			prefix = result.length > 0 ? ':' : '';
			suffix = '';
			const wholeDigits = valueString.includes('.') ? valueString.split('.')[0].length : valueString.length;
			const minLength = result.length > 0 ? 2 : 1;
			valueString = '0'.repeat(Math.max(0, minLength - wholeDigits)) + valueString;
		} else {
			prefix = '';
			suffix = options.verbose ? ' ' + pluralize(long, value) : short;
		}

		result.push(prefix + valueString + suffix);
	};

	const secondsDecimalDigits =
		typeof options.secondsDecimalDigits === 'number' ?
			options.secondsDecimalDigits :
			1;

	if (secondsDecimalDigits < 1) {
		const difference = 1000 - (milliseconds % 1000);
		if (difference < 500) {
			milliseconds += difference;
		}
	}

	// Round up milliseconds for values lager than 1 minute - 50ms since these
	// always need to be round up. This fixes issues when rounding seconds
	// independently of minutes later on.
	if (
		milliseconds >= (1000 * 60) - 50 &&
		!options.separateMilliseconds &&
		!options.formatSubMilliseconds
	) {
		const difference = 60 - (milliseconds % 60);
		if (difference <= 50) {
			milliseconds += difference;
		}
	}

	const parsed = parseMs(milliseconds);

	add(Math.trunc(parsed.days / 365), 'year', 'y');
	add(parsed.days % 365, 'day', 'd');
	add(parsed.hours, 'hour', 'h');
	add(parsed.minutes, 'minute', 'm');

	if (
		options.separateMilliseconds ||
		options.formatSubMilliseconds ||
		milliseconds < 1000
	) {
		add(parsed.seconds, 'second', 's');
		if (options.formatSubMilliseconds) {
			add(parsed.milliseconds, 'millisecond', 'ms');
			add(parsed.microseconds, 'microsecond', 'µs');
			add(parsed.nanoseconds, 'nanosecond', 'ns');
		} else {
			const millisecondsAndBelow =
				parsed.milliseconds +
				(parsed.microseconds / 1000) +
				(parsed.nanoseconds / 1e6);

			const millisecondsDecimalDigits =
				typeof options.millisecondsDecimalDigits === 'number' ?
					options.millisecondsDecimalDigits :
					0;

			const roundedMiliseconds = millisecondsAndBelow >= 1 ?
				Math.round(millisecondsAndBelow) :
				Math.ceil(millisecondsAndBelow);

			const millisecondsString = millisecondsDecimalDigits ?
				millisecondsAndBelow.toFixed(millisecondsDecimalDigits) :
				roundedMiliseconds;

			add(
				parseFloat(millisecondsString, 10),
				'millisecond',
				'ms',
				millisecondsString
			);
		}
	} else {
		const seconds = (milliseconds / 1000) % 60;
		const secondsDecimalDigits =
			typeof options.secondsDecimalDigits === 'number' ?
				options.secondsDecimalDigits :
				1;
		const secondsFixed = seconds.toFixed(secondsDecimalDigits);
		const secondsString = options.keepDecimalsOnWholeSeconds ?
			secondsFixed :
			secondsFixed.replace(/\.0+$/, '');
		add(parseFloat(secondsString, 10), 'second', 's', secondsString);
	}

	if (result.length === 0) {
		return '0' + (options.verbose ? ' milliseconds' : 'ms');
	}

	if (options.compact) {
		return result[0];
	}

	if (typeof options.unitCount === 'number') {
		const separator = options.colonNotation ? '' : ' ';
		return result.slice(0, Math.max(options.unitCount, 1)).join(separator);
	}

	return options.colonNotation ? result.join('') : result.join(' ');
};

let SOURCEMAPPING_URL = 'sourceMa';
SOURCEMAPPING_URL += 'ppingURL';
var SOURCEMAPPING_URL$1 = SOURCEMAPPING_URL;

const BYTE_UNITS = [
	'B',
	'kB',
	'MB',
	'GB',
	'TB',
	'PB',
	'EB',
	'ZB',
	'YB'
];

const BIT_UNITS = [
	'b',
	'kbit',
	'Mbit',
	'Gbit',
	'Tbit',
	'Pbit',
	'Ebit',
	'Zbit',
	'Ybit'
];

/*
Formats the given number using `Number#toLocaleString`.
- If locale is a string, the value is expected to be a locale-key (for example: `de`).
- If locale is true, the system default locale is used for translation.
- If no value for locale is specified, the number is returned unmodified.
*/
const toLocaleString = (number, locale) => {
	let result = number;
	if (typeof locale === 'string') {
		result = number.toLocaleString(locale);
	} else if (locale === true) {
		result = number.toLocaleString();
	}

	return result;
};

var prettyBytes = (number, options) => {
	if (!Number.isFinite(number)) {
		throw new TypeError(`Expected a finite number, got ${typeof number}: ${number}`);
	}

	options = Object.assign({bits: false}, options);
	const UNITS = options.bits ? BIT_UNITS : BYTE_UNITS;

	if (options.signed && number === 0) {
		return ' 0 ' + UNITS[0];
	}

	const isNegative = number < 0;
	const prefix = isNegative ? '-' : (options.signed ? '+' : '');

	if (isNegative) {
		number = -number;
	}

	if (number < 1) {
		const numberString = toLocaleString(number, options.locale);
		return prefix + numberString + ' ' + UNITS[0];
	}

	const exponent = Math.min(Math.floor(Math.log10(number) / 3), UNITS.length - 1);
	// eslint-disable-next-line unicorn/prefer-exponentiation-operator
	number = Number((number / Math.pow(1000, exponent)).toPrecision(3));
	const numberString = toLocaleString(number, options.locale);

	const unit = UNITS[exponent];

	return prefix + numberString + ' ' + unit;
};

function printTimings(timings) {
    Object.keys(timings).forEach(label => {
        const appliedColor = label[0] === '#' ? (label[1] !== '#' ? commandPlugins.color.underline : commandPlugins.color.bold) : (text) => text;
        const [time, memory, total] = timings[label];
        const row = `${label}: ${time.toFixed(0)}ms, ${prettyBytes(memory)} / ${prettyBytes(total)}`;
        console.info(appliedColor(row));
    });
}

async function build(inputOptions, warnings, silent = false) {
    const outputOptions = inputOptions.output;
    const useStdout = !outputOptions[0].file && !outputOptions[0].dir;
    const start = Date.now();
    const files = useStdout ? ['stdout'] : outputOptions.map((t) => rollup_js.relativeId(t.file || t.dir));
    if (!silent) {
        let inputFiles;
        if (typeof inputOptions.input === 'string') {
            inputFiles = inputOptions.input;
        }
        else if (inputOptions.input instanceof Array) {
            inputFiles = inputOptions.input.join(', ');
        }
        else if (typeof inputOptions.input === 'object' && inputOptions.input !== null) {
            inputFiles = Object.keys(inputOptions.input)
                .map((name) => inputOptions.input[name])
                .join(', ');
        }
        commandPlugins.stderr(commandPlugins.color.cyan(`\n${commandPlugins.color.bold(inputFiles)} → ${commandPlugins.color.bold(files.join(', '))}...`));
    }
    const bundle = await rollup_js.rollup(inputOptions);
    if (useStdout) {
        const output = outputOptions[0];
        if (output.sourcemap && output.sourcemap !== 'inline') {
            commandPlugins.handleError({
                code: 'ONLY_INLINE_SOURCEMAPS',
                message: 'Only inline sourcemaps are supported when bundling to stdout.',
            });
        }
        const { output: outputs } = await bundle.generate(output);
        for (const file of outputs) {
            let source;
            if (file.type === 'asset') {
                source = file.source;
            }
            else {
                source = file.code;
                if (output.sourcemap === 'inline') {
                    source += `\n//# ${SOURCEMAPPING_URL$1}=${file.map.toUrl()}\n`;
                }
            }
            if (outputs.length > 1)
                process.stdout.write(`\n${commandPlugins.color.cyan(commandPlugins.color.bold(`//→ ${file.fileName}:`))}\n`);
            process.stdout.write(source);
        }
        if (!silent) {
            warnings.flush();
        }
        return;
    }
    await Promise.all(outputOptions.map(bundle.write));
    if (!silent) {
        warnings.flush();
        commandPlugins.stderr(commandPlugins.color.green(`created ${commandPlugins.color.bold(files.join(', '))} in ${commandPlugins.color.bold(prettyMs(Date.now() - start))}`));
        if (bundle && bundle.getTimings) {
            printTimings(bundle.getTimings());
        }
    }
}

var modules = {};

var getModule = function(dir) {
  var rootPath = dir ? _events_commonjsExternal.sysPath.resolve(dir) : process.cwd();
  var rootName = _events_commonjsExternal.sysPath.join(rootPath, '@root');
  var root = modules[rootName];
  if (!root) {
    root = new module$1(rootName);
    root.filename = rootName;
    root.paths = module$1._nodeModulePaths(rootPath);
    modules[rootName] = root;
  }
  return root;
};

var requireRelative = function(requested, relativeTo) {
  var root = getModule(relativeTo);
  return root.require(requested);
};

requireRelative.resolve = function(requested, relativeTo) {
  var root = getModule(relativeTo);
  return module$1._resolveFilename(requested, root);
};

var requireRelative_1 = requireRelative;

const DEFAULT_CONFIG_BASE = 'rollup.config';
function getConfigPath(commandConfig) {
    const cwd = process.cwd();
    if (commandConfig === true) {
        return path.join(cwd, findConfigFileNameInCwd());
    }
    if (commandConfig.slice(0, 5) === 'node:') {
        const pkgName = commandConfig.slice(5);
        try {
            return requireRelative_1.resolve(`rollup-config-${pkgName}`, cwd);
        }
        catch (err) {
            try {
                return requireRelative_1.resolve(pkgName, cwd);
            }
            catch (err) {
                if (err.code === 'MODULE_NOT_FOUND') {
                    commandPlugins.handleError({
                        code: 'MISSING_EXTERNAL_CONFIG',
                        message: `Could not resolve config file "${commandConfig}"`
                    });
                }
                throw err;
            }
        }
    }
    return fs.realpathSync(commandConfig);
}
function findConfigFileNameInCwd() {
    const filesInWorkingDir = new Set(fs.readdirSync(process.cwd()));
    for (const extension of ['mjs', 'cjs']) {
        const fileName = `${DEFAULT_CONFIG_BASE}.${extension}`;
        if (filesInWorkingDir.has(fileName))
            return fileName;
    }
    return `${DEFAULT_CONFIG_BASE}.js`;
}

function supportsNativeESM() {
    return Number(/^v(\d+)/.exec(process.version)[1]) >= 13;
}
async function loadAndParseConfigFile(fileName, commandOptions = {}) {
    const configs = await loadConfigFile(fileName, commandOptions);
    const warnings = commandPlugins.batchWarnings();
    try {
        const normalizedConfigs = configs.map((config) => {
            const options = mergeOptions.mergeOptions(config, commandOptions, warnings.add);
            commandPlugins.addCommandPluginsToInputOptions(options, commandOptions);
            return options;
        });
        return { options: normalizedConfigs, warnings };
    }
    catch (err) {
        warnings.flush();
        throw err;
    }
}
async function loadConfigFile(fileName, commandOptions) {
    const extension = path.extname(fileName);
    const configFileExport = extension === '.mjs' && supportsNativeESM()
        ? (await import(url.pathToFileURL(fileName).href)).default
        : extension === '.cjs'
            ? getDefaultFromCjs(require(fileName))
            : await getDefaultFromTranspiledConfigFile(fileName, commandOptions.silent);
    return getConfigList(configFileExport, commandOptions);
}
function getDefaultFromCjs(namespace) {
    return namespace.__esModule ? namespace.default : namespace;
}
async function getDefaultFromTranspiledConfigFile(fileName, silent) {
    const warnings = commandPlugins.batchWarnings();
    const bundle = await rollup_js.rollup({
        external: (id) => (id[0] !== '.' && !path.isAbsolute(id)) || id.slice(-5, id.length) === '.json',
        input: fileName,
        onwarn: warnings.add,
        treeshake: false,
    });
    if (!silent && warnings.count > 0) {
        commandPlugins.stderr(commandPlugins.color.bold(`loaded ${rollup_js.relativeId(fileName)} with warnings`));
        warnings.flush();
    }
    const { output: [{ code }], } = await bundle.generate({
        exports: 'named',
        format: 'cjs',
    });
    return loadConfigFromBundledFile(fileName, code);
}
async function loadConfigFromBundledFile(fileName, bundledCode) {
    const extension = path.extname(fileName);
    const defaultLoader = require.extensions[extension];
    require.extensions[extension] = (module, filename) => {
        if (filename === fileName) {
            module._compile(bundledCode, filename);
        }
        else {
            defaultLoader(module, filename);
        }
    };
    delete require.cache[fileName];
    try {
        const config = getDefaultFromCjs(require(fileName));
        require.extensions[extension] = defaultLoader;
        return config;
    }
    catch (err) {
        if (err.code === 'ERR_REQUIRE_ESM') {
            return rollup_js.error({
                code: 'TRANSPILED_ESM_CONFIG',
                message: `While loading the Rollup configuration from "${rollup_js.relativeId(fileName)}", Node tried to require an ES module from a CommonJS file, which is not supported. A common cause is if there is a package.json file with "type": "module" in the same folder. You can try to fix this by changing the extension of your configuration file to ".cjs" or ".mjs" depending on the content, which will prevent Rollup from trying to preprocess the file but rather hand it to Node directly.`,
                url: 'https://rollupjs.org/guide/en/#using-untranspiled-config-files',
            });
        }
        throw err;
    }
}
async function getConfigList(configFileExport, commandOptions) {
    const config = await (typeof configFileExport === 'function'
        ? configFileExport(commandOptions)
        : configFileExport);
    if (Object.keys(config).length === 0) {
        return rollup_js.error({
            code: 'MISSING_CONFIG',
            message: 'Config file must export an options object, or an array of options objects',
            url: 'https://rollupjs.org/guide/en/#configuration-files',
        });
    }
    return Array.isArray(config) ? config : [config];
}

function loadConfigFromCommand(command) {
    const warnings = commandPlugins.batchWarnings();
    if (!command.input && (command.stdin || !process.stdin.isTTY)) {
        command.input = commandPlugins.stdinName;
    }
    const options = mergeOptions.mergeOptions({ input: [] }, command, warnings.add);
    commandPlugins.addCommandPluginsToInputOptions(options, command);
    return { options: [options], warnings };
}

var timeZone = date => {
	const offset = (date || new Date()).getTimezoneOffset();
	const absOffset = Math.abs(offset);
	const hours = Math.floor(absOffset / 60);
	const minutes = absOffset % 60;
	const minutesOut = minutes > 0 ? ':' + ('0' + minutes).slice(-2) : '';

	return (offset < 0 ? '+' : '-') + hours + minutesOut;
};

const dateTime = options => {
	options = Object.assign({
		date: new Date(),
		local: true,
		showTimeZone: false,
		showMilliseconds: false
	}, options);

	let {date} = options;

	if (options.local) {
		// Offset the date so it will return the correct value when getting the ISO string
		date = new Date(date.getTime() - (date.getTimezoneOffset() * 60000));
	}

	let end = '';

	if (options.showTimeZone) {
		end = ' UTC' + (options.local ? timeZone(date) : '');
	}

	if (options.showMilliseconds && date.getUTCMilliseconds() > 0) {
		end = ` ${date.getUTCMilliseconds()}ms${end}`;
	}

	return date
		.toISOString()
		.replace(/T/, ' ')
		.replace(/\..+/, end);
};

var dateTime_1 = dateTime;
// TODO: Remove this for the next major release
var default_1$1 = dateTime;
dateTime_1.default = default_1$1;

var signals = rollup_js.createCommonjsModule(function (module) {
// This is not the set of all possible signals.
//
// It IS, however, the set of all signals that trigger
// an exit on either Linux or BSD systems.  Linux is a
// superset of the signal names supported on BSD, and
// the unknown signals just fail to register, so we can
// catch that easily enough.
//
// Don't bother with SIGKILL.  It's uncatchable, which
// means that we can't fire any callbacks anyway.
//
// If a user does happen to register a handler on a non-
// fatal signal like SIGWINCH or something, and then
// exit, it'll end up firing `process.emit('exit')`, so
// the handler will be fired anyway.
//
// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
// artificially, inherently leave the process in a
// state from which it is not safe to try and enter JS
// listeners.
module.exports = [
  'SIGABRT',
  'SIGALRM',
  'SIGHUP',
  'SIGINT',
  'SIGTERM'
];

if (process.platform !== 'win32') {
  module.exports.push(
    'SIGVTALRM',
    'SIGXCPU',
    'SIGXFSZ',
    'SIGUSR2',
    'SIGTRAP',
    'SIGSYS',
    'SIGQUIT',
    'SIGIOT'
    // should detect profiler and enable/disable accordingly.
    // see #21
    // 'SIGPROF'
  );
}

if (process.platform === 'linux') {
  module.exports.push(
    'SIGIO',
    'SIGPOLL',
    'SIGPWR',
    'SIGSTKFLT',
    'SIGUNUSED'
  );
}
});

// Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.

var signals$1 = signals;

var EE = _events_commonjsExternal.require$$0;
/* istanbul ignore if */
if (typeof EE !== 'function') {
  EE = EE.EventEmitter;
}

var emitter;
if (process.__signal_exit_emitter__) {
  emitter = process.__signal_exit_emitter__;
} else {
  emitter = process.__signal_exit_emitter__ = new EE();
  emitter.count = 0;
  emitter.emitted = {};
}

// Because this emitter is a global, we have to check to see if a
// previous version of this library failed to enable infinite listeners.
// I know what you're about to say.  But literally everything about
// signal-exit is a compromise with evil.  Get used to it.
if (!emitter.infinite) {
  emitter.setMaxListeners(Infinity);
  emitter.infinite = true;
}

var signalExit = function (cb, opts) {
  assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler');

  if (loaded === false) {
    load();
  }

  var ev = 'exit';
  if (opts && opts.alwaysLast) {
    ev = 'afterexit';
  }

  var remove = function () {
    emitter.removeListener(ev, cb);
    if (emitter.listeners('exit').length === 0 &&
        emitter.listeners('afterexit').length === 0) {
      unload();
    }
  };
  emitter.on(ev, cb);

  return remove
};

var unload_1 = unload;
function unload () {
  if (!loaded) {
    return
  }
  loaded = false;

  signals$1.forEach(function (sig) {
    try {
      process.removeListener(sig, sigListeners[sig]);
    } catch (er) {}
  });
  process.emit = originalProcessEmit;
  process.reallyExit = originalProcessReallyExit;
  emitter.count -= 1;
}

function emit (event, code, signal) {
  if (emitter.emitted[event]) {
    return
  }
  emitter.emitted[event] = true;
  emitter.emit(event, code, signal);
}

// { <signal>: <listener fn>, ... }
var sigListeners = {};
signals$1.forEach(function (sig) {
  sigListeners[sig] = function listener () {
    // If there are no other listeners, an exit is coming!
    // Simplest way: remove us and then re-send the signal.
    // We know that this will kill the process, so we can
    // safely emit now.
    var listeners = process.listeners(sig);
    if (listeners.length === emitter.count) {
      unload();
      emit('exit', null, sig);
      /* istanbul ignore next */
      emit('afterexit', null, sig);
      /* istanbul ignore next */
      process.kill(process.pid, sig);
    }
  };
});

var signals_1 = function () {
  return signals$1
};

var load_1 = load;

var loaded = false;

function load () {
  if (loaded) {
    return
  }
  loaded = true;

  // This is the number of onSignalExit's that are in play.
  // It's important so that we can count the correct number of
  // listeners on signals, and don't wait for the other one to
  // handle it instead of us.
  emitter.count += 1;

  signals$1 = signals$1.filter(function (sig) {
    try {
      process.on(sig, sigListeners[sig]);
      return true
    } catch (er) {
      return false
    }
  });

  process.emit = processEmit;
  process.reallyExit = processReallyExit;
}

var originalProcessReallyExit = process.reallyExit;
function processReallyExit (code) {
  process.exitCode = code || 0;
  emit('exit', process.exitCode, null);
  /* istanbul ignore next */
  emit('afterexit', process.exitCode, null);
  /* istanbul ignore next */
  originalProcessReallyExit.call(process, process.exitCode);
}

var originalProcessEmit = process.emit;
function processEmit (ev, arg) {
  if (ev === 'exit') {
    if (arg !== undefined) {
      process.exitCode = arg;
    }
    var ret = originalProcessEmit.apply(this, arguments);
    emit('exit', process.exitCode, null);
    /* istanbul ignore next */
    emit('afterexit', process.exitCode, null);
    return ret
  } else {
    return originalProcessEmit.apply(this, arguments)
  }
}
signalExit.unload = unload_1;
signalExit.signals = signals_1;
signalExit.load = load_1;

const CLEAR_SCREEN = '\u001Bc';
function getResetScreen(configs, allowClearScreen) {
    let clearScreen = allowClearScreen;
    for (const config of configs) {
        if (config.watch && config.watch.clearScreen === false) {
            clearScreen = false;
        }
    }
    if (clearScreen) {
        return (heading) => commandPlugins.stderr(CLEAR_SCREEN + heading);
    }
    let firstRun = true;
    return (heading) => {
        if (firstRun) {
            commandPlugins.stderr(heading);
            firstRun = false;
        }
    };
}

async function watch(command) {
    process.env.ROLLUP_WATCH = 'true';
    const isTTY = process.stderr.isTTY;
    const silent = command.silent;
    let configs;
    let warnings;
    let watcher;
    let configWatcher;
    const configFile = command.config ? getConfigPath(command.config) : null;
    signalExit(close);
    process.on('uncaughtException', close);
    // only listen to stdin if it is a pipe
    if (!process.stdin.isTTY) {
        process.stdin.on('end', close);
    }
    if (configFile) {
        let reloadingConfig = false;
        let aborted = false;
        let configFileData = null;
        configWatcher = fs.watch(configFile, (event) => {
            if (event === 'change')
                reloadConfigFile();
        });
        await reloadConfigFile();
        async function reloadConfigFile() {
            try {
                const newConfigFileData = fs.readFileSync(configFile, 'utf-8');
                if (newConfigFileData === configFileData) {
                    return;
                }
                if (reloadingConfig) {
                    aborted = true;
                    return;
                }
                if (configFileData) {
                    commandPlugins.stderr(`\nReloading updated config...`);
                }
                configFileData = newConfigFileData;
                reloadingConfig = true;
                ({ options: configs, warnings } = await loadAndParseConfigFile(configFile, command));
                reloadingConfig = false;
                if (aborted) {
                    aborted = false;
                    reloadConfigFile();
                }
                else {
                    if (watcher) {
                        watcher.close();
                    }
                    start(configs);
                }
            }
            catch (err) {
                configs = [];
                reloadingConfig = false;
                commandPlugins.handleError(err, true);
            }
        }
    }
    else {
        ({ options: configs, warnings } = await loadConfigFromCommand(command));
        start(configs);
    }
    // tslint:disable-next-line:no-unnecessary-type-assertion
    const resetScreen = getResetScreen(configs, isTTY);
    function start(configs) {
        watcher = rollup_js.watch(configs);
        watcher.on('event', (event) => {
            switch (event.code) {
                case 'ERROR':
                    warnings.flush();
                    commandPlugins.handleError(event.error, true);
                    break;
                case 'START':
                    if (!silent) {
                        resetScreen(commandPlugins.color.underline(`rollup v${rollup_js.version}`));
                    }
                    break;
                case 'BUNDLE_START':
                    if (!silent) {
                        let input = event.input;
                        if (typeof input !== 'string') {
                            input = Array.isArray(input)
                                ? input.join(', ')
                                : Object.keys(input)
                                    .map((key) => input[key])
                                    .join(', ');
                        }
                        commandPlugins.stderr(commandPlugins.color.cyan(`bundles ${commandPlugins.color.bold(input)} → ${commandPlugins.color.bold(event.output.map(rollup_js.relativeId).join(', '))}...`));
                    }
                    break;
                case 'BUNDLE_END':
                    warnings.flush();
                    if (!silent)
                        commandPlugins.stderr(commandPlugins.color.green(`created ${commandPlugins.color.bold(event.output.map(rollup_js.relativeId).join(', '))} in ${commandPlugins.color.bold(prettyMs(event.duration))}`));
                    if (event.result && event.result.getTimings) {
                        printTimings(event.result.getTimings());
                    }
                    break;
                case 'END':
                    if (!silent && isTTY) {
                        commandPlugins.stderr(`\n[${dateTime_1()}] waiting for changes...`);
                    }
            }
        });
    }
    function close(err) {
        process.removeListener('uncaughtException', close);
        // removing a non-existent listener is a no-op
        process.stdin.removeListener('end', close);
        if (watcher)
            watcher.close();
        if (configWatcher)
            configWatcher.close();
        if (err) {
            commandPlugins.stderr(err);
            process.exit(1);
        }
    }
}

async function runRollup(command) {
    let inputSource;
    if (command._.length > 0) {
        if (command.input) {
            commandPlugins.handleError({
                code: 'DUPLICATE_IMPORT_OPTIONS',
                message: 'Either use --input, or pass input path as argument',
            });
        }
        inputSource = command._;
    }
    else if (typeof command.input === 'string') {
        inputSource = [command.input];
    }
    else {
        inputSource = command.input;
    }
    if (inputSource && inputSource.length > 0) {
        if (inputSource.some((input) => input.indexOf('=') !== -1)) {
            command.input = {};
            inputSource.forEach((input) => {
                const equalsIndex = input.indexOf('=');
                const value = input.substr(equalsIndex + 1);
                let key = input.substr(0, equalsIndex);
                if (!key)
                    key = rollup_js.getAliasName(input);
                command.input[key] = value;
            });
        }
        else {
            command.input = inputSource;
        }
    }
    if (command.environment) {
        const environment = Array.isArray(command.environment)
            ? command.environment
            : [command.environment];
        environment.forEach((arg) => {
            arg.split(',').forEach((pair) => {
                const [key, ...value] = pair.split(':');
                if (value.length) {
                    process.env[key] = value.join(':');
                }
                else {
                    process.env[key] = String(true);
                }
            });
        });
    }
    if (command.watch) {
        watch(command);
    }
    else {
        try {
            const { options, warnings } = await getConfigs(command);
            try {
                for (const inputOptions of options) {
                    await build(inputOptions, warnings, command.silent);
                }
            }
            catch (err) {
                warnings.flush();
                commandPlugins.handleError(err);
            }
        }
        catch (err) {
            commandPlugins.handleError(err);
        }
    }
}
async function getConfigs(command) {
    if (command.config) {
        const configFile = getConfigPath(command.config);
        const { options, warnings } = await loadAndParseConfigFile(configFile, command);
        return { options, warnings };
    }
    return loadConfigFromCommand(command);
}

const command = yargsParser(process.argv.slice(2), {
    alias: mergeOptions.commandAliases,
    configuration: { 'camel-case-expansion': false }
});
if (command.help || (process.argv.length <= 2 && process.stdin.isTTY)) {
    console.log(`\n${help.replace('__VERSION__', rollup_js.version)}\n`);
}
else if (command.version) {
    console.log(`rollup v${rollup_js.version}`);
}
else {
    try {
        require('source-map-support').install();
    }
    catch (err) {
        // do nothing
    }
    runRollup(command);
}
//# sourceMappingURL=rollup.map
