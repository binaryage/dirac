import Protocol from './protocol';
import { ConnectionTransport } from './ConnectionTransport';
import { EventEmitter } from './EventEmitter';
interface ConnectionCallback {
    resolve: Function;
    reject: Function;
    error: Error;
    method: string;
}
export declare class Connection extends EventEmitter {
    _url: string;
    _transport: ConnectionTransport;
    _delay: number;
    _lastId: number;
    _sessions: Map<string, CDPSession>;
    _closed: boolean;
    _callbacks: Map<number, ConnectionCallback>;
    constructor(url: string, transport: ConnectionTransport, delay?: number);
    static fromSession(session: CDPSession): Connection;
    /**
     * @param {string} sessionId
     * @returns {?CDPSession}
     */
    session(sessionId: string): CDPSession | null;
    url(): string;
    send<T extends keyof Protocol.CommandParameters>(method: T, params?: Protocol.CommandParameters[T]): Promise<Protocol.CommandReturnValues[T]>;
    _rawSend(message: {}): number;
    _onMessage(message: string): Promise<void>;
    _onClose(): void;
    dispose(): void;
    /**
     * @param {Protocol.Target.TargetInfo} targetInfo
     * @returns {!Promise<!CDPSession>}
     */
    createSession(targetInfo: Protocol.Target.TargetInfo): Promise<CDPSession>;
}
interface CDPSessionOnMessageObject {
    id?: number;
    method: string;
    params: {};
    error: {
        message: string;
        data: any;
    };
    result?: any;
}
export declare class CDPSession extends EventEmitter {
    _connection: Connection;
    _sessionId: string;
    _targetType: string;
    _callbacks: Map<number, ConnectionCallback>;
    constructor(connection: Connection, targetType: string, sessionId: string);
    send<T extends keyof Protocol.CommandParameters>(method: T, params?: Protocol.CommandParameters[T]): Promise<Protocol.CommandReturnValues[T]>;
    _onMessage(object: CDPSessionOnMessageObject): void;
    detach(): Promise<void>;
    _onClosed(): void;
}
export {};
//# sourceMappingURL=Connection.d.ts.map