/// <reference types="node" />
/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { CDPSession } from './Connection';
import { Frame } from './FrameManager';
import { HTTPResponse } from './HTTPResponse';
import Protocol from './protocol';
export declare class HTTPRequest {
    _requestId: string;
    _interceptionId: string;
    _failureText: any;
    _response: HTTPResponse | null;
    _fromMemoryCache: boolean;
    _redirectChain: HTTPRequest[];
    private _client;
    private _isNavigationRequest;
    private _allowInterception;
    private _interceptionHandled;
    private _url;
    private _resourceType;
    private _method;
    private _postData?;
    private _headers;
    private _frame;
    constructor(client: CDPSession, frame: Frame, interceptionId: string, allowInterception: boolean, event: Protocol.Network.requestWillBeSentPayload, redirectChain: HTTPRequest[]);
    url(): string;
    resourceType(): string;
    method(): string;
    postData(): string | undefined;
    headers(): Record<string, string>;
    response(): HTTPResponse | null;
    frame(): Frame | null;
    isNavigationRequest(): boolean;
    redirectChain(): HTTPRequest[];
    /**
     * @returns {?{errorText: string}}
     */
    failure(): {
        errorText: string;
    } | null;
    continue(overrides?: {
        url?: string;
        method?: string;
        postData?: string;
        headers?: Record<string, string>;
    }): Promise<void>;
    respond(response: {
        status: number;
        headers: Record<string, string>;
        contentType: string;
        body: string | Buffer;
    }): Promise<void>;
    abort(errorCode?: ErrorCode): Promise<void>;
}
declare type ErrorCode = 'aborted' | 'accessdenied' | 'addressunreachable' | 'blockedbyclient' | 'blockedbyresponse' | 'connectionaborted' | 'connectionclosed' | 'connectionfailed' | 'connectionrefused' | 'connectionreset' | 'internetdisconnected' | 'namenotresolved' | 'timedout' | 'failed';
export {};
//# sourceMappingURL=HTTPRequest.d.ts.map