/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference types="node" />
import { Target } from './Target';
import { EventEmitter } from './EventEmitter';
import Protocol from './protocol';
import { Connection } from './Connection';
import { Page } from './Page';
import { ChildProcess } from 'child_process';
import { Viewport } from './PuppeteerViewport';
declare type BrowserCloseCallback = () => Promise<void> | void;
export declare class Browser extends EventEmitter {
    static create(connection: Connection, contextIds: string[], ignoreHTTPSErrors: boolean, defaultViewport?: Viewport, process?: ChildProcess, closeCallback?: BrowserCloseCallback): Promise<Browser>;
    _ignoreHTTPSErrors: boolean;
    _defaultViewport?: Viewport;
    _process?: ChildProcess;
    _connection: Connection;
    _closeCallback: BrowserCloseCallback;
    _defaultContext: BrowserContext;
    _contexts: Map<string, BrowserContext>;
    _targets: Map<string, Target>;
    constructor(connection: Connection, contextIds: string[], ignoreHTTPSErrors: boolean, defaultViewport?: Viewport, process?: ChildProcess, closeCallback?: BrowserCloseCallback);
    process(): ChildProcess | null;
    createIncognitoBrowserContext(): Promise<BrowserContext>;
    browserContexts(): BrowserContext[];
    defaultBrowserContext(): BrowserContext;
    /**
     * @param {?string} contextId
     */
    _disposeContext(contextId?: string): Promise<void>;
    _targetCreated(event: Protocol.Target.targetCreatedPayload): Promise<void>;
    /**
     * @param {{targetId: string}} event
     */
    _targetDestroyed(event: {
        targetId: string;
    }): Promise<void>;
    /**
     * @param {!Protocol.Target.targetInfoChangedPayload} event
     */
    _targetInfoChanged(event: Protocol.Target.targetInfoChangedPayload): void;
    wsEndpoint(): string;
    newPage(): Promise<Page>;
    _createPageInContext(contextId?: string): Promise<Page>;
    targets(): Target[];
    target(): Target;
    /**
     * @param {function(!Target):boolean} predicate
     * @param {{timeout?: number}=} options
     * @returns {!Promise<!Target>}
     */
    waitForTarget(predicate: (x: Target) => boolean, options?: {
        timeout?: number;
    }): Promise<Target>;
    pages(): Promise<Page[]>;
    version(): Promise<string>;
    userAgent(): Promise<string>;
    close(): Promise<void>;
    disconnect(): void;
    isConnected(): boolean;
    _getVersion(): Promise<Protocol.Browser.getVersionReturnValue>;
}
export declare class BrowserContext extends EventEmitter {
    _connection: Connection;
    _browser: Browser;
    _id?: string;
    constructor(connection: Connection, browser: Browser, contextId?: string);
    targets(): Target[];
    waitForTarget(predicate: (x: Target) => boolean, options: {
        timeout?: number;
    }): Promise<Target>;
    pages(): Promise<Page[]>;
    isIncognito(): boolean;
    overridePermissions(origin: string, permissions: Protocol.Browser.PermissionType[]): Promise<void>;
    clearPermissionOverrides(): Promise<void>;
    newPage(): Promise<Page>;
    browser(): Browser;
    close(): Promise<void>;
}
export {};
//# sourceMappingURL=Browser.d.ts.map