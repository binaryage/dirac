/**
 * Copyright 2019 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference types="node" />
import { ExecutionContext } from './ExecutionContext';
import { Page } from './Page';
import { CDPSession } from './Connection';
import { KeyInput } from './USKeyboardLayout';
import { FrameManager, Frame } from './FrameManager';
import Protocol from './protocol';
interface BoxModel {
    content: Array<{
        x: number;
        y: number;
    }>;
    padding: Array<{
        x: number;
        y: number;
    }>;
    border: Array<{
        x: number;
        y: number;
    }>;
    margin: Array<{
        x: number;
        y: number;
    }>;
    width: number;
    height: number;
}
export declare function createJSHandle(context: ExecutionContext, remoteObject: Protocol.Runtime.RemoteObject): JSHandle;
export declare class JSHandle {
    _context: ExecutionContext;
    _client: CDPSession;
    _remoteObject: Protocol.Runtime.RemoteObject;
    _disposed: boolean;
    constructor(context: ExecutionContext, client: CDPSession, remoteObject: Protocol.Runtime.RemoteObject);
    executionContext(): ExecutionContext;
    evaluate<ReturnType extends any>(pageFunction: Function | string, ...args: unknown[]): Promise<ReturnType>;
    evaluateHandle(pageFunction: Function | string, ...args: unknown[]): Promise<JSHandle>;
    getProperty(propertyName: string): Promise<JSHandle | undefined>;
    getProperties(): Promise<Map<string, JSHandle>>;
    jsonValue(): Promise<{}>;
    asElement(): ElementHandle | null;
    dispose(): Promise<void>;
    toString(): string;
}
export declare class ElementHandle extends JSHandle {
    _page: Page;
    _frameManager: FrameManager;
    constructor(context: ExecutionContext, client: CDPSession, remoteObject: Protocol.Runtime.RemoteObject, page: Page, frameManager: FrameManager);
    asElement(): ElementHandle | null;
    contentFrame(): Promise<Frame | null>;
    _scrollIntoViewIfNeeded(): Promise<void>;
    _clickablePoint(): Promise<{
        x: number;
        y: number;
    }>;
    _getBoxModel(): Promise<void | Protocol.DOM.getBoxModelReturnValue>;
    _fromProtocolQuad(quad: number[]): Array<{
        x: number;
        y: number;
    }>;
    _intersectQuadWithViewport(quad: Array<{
        x: number;
        y: number;
    }>, width: number, height: number): Array<{
        x: number;
        y: number;
    }>;
    hover(): Promise<void>;
    click(options: {
        delay?: number;
        button?: 'left' | 'right' | 'middle';
        clickCount?: number;
    }): Promise<void>;
    select(...values: string[]): Promise<string[]>;
    uploadFile(...filePaths: string[]): Promise<void>;
    tap(): Promise<void>;
    focus(): Promise<void>;
    type(text: string, options?: {
        delay: number;
    }): Promise<void>;
    press(key: KeyInput, options?: {
        delay?: number;
        text?: string;
    }): Promise<void>;
    boundingBox(): Promise<{
        x: number;
        y: number;
        width: number;
        height: number;
    }>;
    /**
     * @returns {!Promise<?BoxModel>}
     */
    boxModel(): Promise<BoxModel | null>;
    screenshot(options?: {}): Promise<string | Buffer | void>;
    $(selector: string): Promise<ElementHandle | null>;
    $$(selector: string): Promise<ElementHandle[]>;
    $eval<ReturnType extends any>(selector: string, pageFunction: Function | string, ...args: unknown[]): Promise<ReturnType>;
    $$eval<ReturnType extends any>(selector: string, pageFunction: Function | string, ...args: unknown[]): Promise<ReturnType>;
    $x(expression: string): Promise<ElementHandle[]>;
    isIntersectingViewport(): Promise<boolean>;
}
export {};
//# sourceMappingURL=JSHandle.d.ts.map